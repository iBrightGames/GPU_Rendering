

// #pragma kernel CSMain

// struct InstanceData
// {
//     float3 position;
//     int active;
// };

// // Input/Output buffers
// RWStructuredBuffer<InstanceData> _ComputeInstanceDataBuffer;
// AppendStructuredBuffer<InstanceData> activeBuffer;
// AppendStructuredBuffer<InstanceData> filteredBuffer;

// // Shader parameters
// float3 playerPos;
// float radius;
// uint maxInstances;

// // Optimized with better thread group size
// [numthreads(64, 1, 1)]
// void CSMain(uint3 id : SV_DispatchThreadID)
// {
//     uint idx = id.x;
//     if (idx >= maxInstances) return;

//     InstanceData data = _ComputeInstanceDataBuffer[idx];
    
//     // Early exit if already inactive
//     if (data.active == 0)
//         return;

//     // Calculate distance using squared distance for performance
//     float3 diff = data.position - playerPos;
//     float distSq = dot(diff, diff);
//     float radiusSq = radius * radius;
    
//     // Check if within erase radius
//     if (distSq < radiusSq)
//     {
//         // Deactivate instance
//         data.active = 0;
//         _ComputeInstanceDataBuffer[idx] = data;
        
//         // Add to filtered buffer for CPU tracking
//         filteredBuffer.Append(data);
//     }
//     else
//     {
//         // Still active, add to active buffer for rendering
//         activeBuffer.Append(data);
//     }
// }
#pragma kernel CSMain
#pragma kernel CSUpdateArgs

struct InstanceData
{
    float3 position;
    int active;
};

// Buffers
StructuredBuffer<InstanceData> _ComputeInstanceDataBuffer; // Read-only yap
AppendStructuredBuffer<InstanceData> activeBuffer;
AppendStructuredBuffer<InstanceData> filteredBuffer;
RWStructuredBuffer<uint> argsBuffer;

// Shader parameters
float3 playerPos;
float radius;
uint maxInstances;

[numthreads(64,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint idx = id.x;
    if (idx >= maxInstances) return;

    InstanceData data = _ComputeInstanceDataBuffer[idx];
    
    // Zaten inactive olanları filtreleme
    if (data.active == 0) 
    {
        filteredBuffer.Append(data);
        return;
    }

    // Mesafe kontrolü
    float3 diff = data.position - playerPos;
    float distSq = dot(diff, diff);
    float radiusSq = radius * radius;

    if (distSq < radiusSq)
    {
        // Sadece append buffer'lara yaz, original buffer'ı değiştirme
        InstanceData erasedData = data;
        erasedData.active = 0;
        filteredBuffer.Append(erasedData);
    }
    else
    {
        activeBuffer.Append(data);
    }
}

[numthreads(1,1,1)]
void CSUpdateArgs(uint3 id : SV_DispatchThreadID)
{
    // Append buffer'ın gerçek eleman sayısını al
    uint instanceCount = activeBuffer.GetAppendDataCount();
    argsBuffer[1] = instanceCount;
}
