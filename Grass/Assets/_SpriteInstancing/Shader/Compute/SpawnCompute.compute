// SpawnCompute.compute
#pragma kernel BoxRandom
#pragma kernel BoxGrid  
#pragma kernel BoxLayered
#pragma kernel SphereRandom
#pragma kernel SphereUniform
#pragma kernel SphereLayered

RWStructuredBuffer<float3> Positions;
uint PointCount;
float3 Data1; // minPosition / center
float3 Data2; // maxPosition / radius params  
float3 Data3; // layerCount / startLayer / etc.
uint RandomSeed;

// Random generator
float Random(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return float(seed) * (1.0 / 4294967296.0);
}

float3 RandomInCube(uint seed)
{
    return float3(
        Random(seed),
        Random(seed + 123),
        Random(seed + 456)
    );
}

// Box Kernels
[numthreads(256,1,1)]
void BoxRandom(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= PointCount) return;
    
    float3 rnd = RandomInCube(id.x + RandomSeed);
    Positions[id.x] = Data1 + (Data2 - Data1) * rnd;
}

[numthreads(256,1,1)]
void BoxGrid(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= PointCount) return;
    
    uint pointsPerAxis = ceil(pow(PointCount, 1.0/3.0));
    uint x = id.x % pointsPerAxis;
    uint y = (id.x / pointsPerAxis) % pointsPerAxis; 
    uint z = id.x / (pointsPerAxis * pointsPerAxis);
    
    float3 t = float3(x, y, z) / max(pointsPerAxis - 1, 1);
    Positions[id.x] = Data1 + (Data2 - Data1) * t;
}

[numthreads(256,1,1)]
void BoxLayered(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= PointCount) return;
    
    uint layerCount = uint(Data3.x);
    uint pointsPerLayer = PointCount / layerCount;
    uint layerIndex = id.x / pointsPerLayer;
    layerIndex = min(layerIndex, layerCount - 1);
    
    float3 fullSize = Data2 - Data1;
    float3 layerSize = fullSize / layerCount;
    
    float3 layerMin = Data1 + layerSize * layerIndex;
    float3 layerMax = layerMin + layerSize;
    
    float3 rnd = RandomInCube(id.x + RandomSeed);
    Positions[id.x] = layerMin + (layerMax - layerMin) * rnd;
}

// Sphere Kernels
[numthreads(256,1,1)]
void SphereRandom(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= PointCount) return;
    
    float radius = Data2.x;
    float3 randomDir = normalize(RandomInCube(id.x + RandomSeed) - 0.5);
    Positions[id.x] = Data1 + randomDir * radius * Random(id.x + RandomSeed + 789);
}

[numthreads(256,1,1)]
void SphereUniform(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= PointCount) return;
    
    float radius = Data2.x;
    float t = id.x / (float)PointCount;
    
    float goldenAngle = 2.399963f; // radians
    float y = 1.0 - (t * 2.0); // y from 1 to -1
    float radiusAtY = sqrt(1.0 - y * y);
    
    float angle = id.x * goldenAngle;
    
    Positions[id.x] = Data1 + float3(
        cos(angle) * radiusAtY * radius,
        y * radius, 
        sin(angle) * radiusAtY * radius
    );
}

[numthreads(256,1,1)]
void SphereLayered(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= PointCount) return;
    
    uint layerCount = uint(Data3.x);
    float startRadius = Data3.y;
    float maxRadius = Data2.x;
    
    uint pointsPerLayer = PointCount / layerCount;
    uint layerIndex = id.x / pointsPerLayer;
    layerIndex = min(layerIndex, layerCount - 1);
    
    float layerT = layerIndex / (float)(layerCount - 1);
    float layerRadius = lerp(startRadius, maxRadius, layerT);
    
    float3 randomDir = normalize(RandomInCube(id.x + RandomSeed) - 0.5);
    Positions[id.x] = Data1 + randomDir * layerRadius * Random(id.x + RandomSeed + 999);
}
