
// using UnityEngine;
// using System.Collections.Generic;
// using UnityEngine;
// using System.Collections.Generic;
// using UnityEngine;
// using UnityEngine.Rendering;
// public class SimpleSpriteInstancer : MonoBehaviour{
//     public SpriteRenderer sourceSprite;
//     public int instanceCount = 10000;
//     public float scaleMultiplier = 1f;
//     public Vector3 minPosition = new Vector3(-10f, -10f, 0f);
//     public Vector3 maxPosition = new Vector3(10f, 10f, 0f);
//     Mesh quadMesh;
//     public Material instancingMaterial;
//     public Matrix4x4[] matrices;
//     void Start(){InitializeMatrices();}

//     void Update(){
//         if (instancingMaterial != null && matrices != null){
//             int batchSize = 1023;
//             for (int i = 0; i < matrices.Length; i += batchSize){
//                 int count = Mathf.Min(batchSize, matrices.Length - i);
//                 Graphics.DrawMeshInstanced(quadMesh, 0, instancingMaterial, matrices, count, null,
//                     UnityEngine.Rendering.ShadowCastingMode.Off, false);}}}

//     Mesh CreateQuad(){
//         Mesh mesh = new Mesh();
//         mesh.vertices = new Vector3[]{
//             new Vector3(-0.5f, -0.5f, 0),
//             new Vector3( 0.5f, -0.5f, 0),
//             new Vector3( 0.5f,  0.5f, 0),
//             new Vector3(-0.5f,  0.5f, 0)};
//         mesh.uv = new Vector2[]{
//             new Vector2(0, 0),
//             new Vector2(1, 0),
//             new Vector2(1, 1),
//             new Vector2(0, 1)};
//         mesh.triangles = new int[] { 0, 1, 2, 0, 2, 3 };
//         return mesh;}

//     Material CreateMaterial(Texture2D tex){
//         Shader shader = Shader.Find("Unlit/Texture");
//         Material mat = new Material(shader);
//         mat.mainTexture = tex;
//         mat.enableInstancing = true;
//         return mat;}


//     [ContextMenu("Regenerate Matrices")]
//     public void InitializeMatrices(){
//         if (sourceSprite == null || sourceSprite.sprite == null){
//             Debug.LogWarning("Source SpriteRenderer veya sprite atanmadı!");return;}

//         if (quadMesh == null)quadMesh = CreateQuad();

//         if (instancingMaterial == null)instancingMaterial = CreateMaterial(sourceSprite.sprite.texture);

//         matrices = new Matrix4x4[instanceCount];
//         for (int i = 0; i < instanceCount; i++){
//             Vector3 pos = new Vector3(
//                 Random.Range(minPosition.x, maxPosition.x),
//                 Random.Range(minPosition.y, maxPosition.y),
//                 Random.Range(minPosition.z, maxPosition.z));
//             matrices[i] = Matrix4x4.TRS(pos, Quaternion.identity, Vector3.one * scaleMultiplier);}
//         sourceSprite.enabled = false;}

//     void OnDrawGizmos(){
//         if (matrices == null) return;
//         Gizmos.color = Color.red;
//         for (int i = 0; i < matrices.Length; i++){
//             Vector3 pos = matrices[i].GetColumn(3);
//             Gizmos.DrawSphere(pos, 0.1f);}}}



// public class SimpleSpriteComputeInstancer : MonoBehaviour{
//     public SpriteRenderer sourceSprite;
//     public int instanceCount = 10000;
//     public float scaleMultiplier = 1f;
//     public Vector3 minPosition = new Vector3(-10f, -10f, 0f);
//     public Vector3 maxPosition = new Vector3(10f, 10f, 0f);
//     public List<Vector3> positions = new List<Vector3>();
//     Mesh quadMesh;
//     public Material instancingMaterial;
//     ComputeBuffer instanceBuffer;

//     struct InstanceData    {
//         public Vector3 position;
//         public float scale;}

//     bool bufferInitialized = false;

//     [ContextMenu("Regenerate Positions")]
//     public void GeneratePositions(){
//         positions.Clear();
//         for (int i = 0; i < instanceCount; i++){
//             Vector3 pos = new Vector3(
//                 Random.Range(minPosition.x, maxPosition.x),
//                 Random.Range(minPosition.y, maxPosition.y),
//                 Random.Range(minPosition.z, maxPosition.z));
//             positions.Add(pos);}
//         UpdateBuffer();}

//     void UpdateBuffer(){
//         if (!bufferInitialized || positions.Count == 0) return;
//         InstanceData[] dataArray = new InstanceData[positions.Count];
//         for (int i = 0; i < positions.Count; i++)
//             dataArray[i] = new InstanceData { position = positions[i], scale = scaleMultiplier };
//         instanceBuffer.SetData(dataArray);}

//     void Start(){
//         if (sourceSprite == null || sourceSprite.sprite == null) return;
//         if (quadMesh == null)
//             quadMesh = CreateQuad();
//         if (instancingMaterial == null){
//             Shader shader = Shader.Find("CustomUnlit/SingleSpriteCompute");
//             instancingMaterial = new Material(shader);
//             instancingMaterial.mainTexture = sourceSprite.sprite.texture;
//             instancingMaterial.enableInstancing = true;}
//         sourceSprite.enabled = false;
//         instanceBuffer = new ComputeBuffer(instanceCount, sizeof(float) * 4);
//         bufferInitialized = true;

//         GeneratePositions();}

//     void Update(){
//         if (!bufferInitialized || positions.Count == 0) return;
//         instancingMaterial.SetBuffer("_InstanceDataBuffer", instanceBuffer);
//         Graphics.DrawMeshInstancedProcedural(
//             quadMesh, 0, instancingMaterial,
//             new Bounds(Vector3.zero, Vector3.one * 100f),
//             positions.Count);}

//     void OnDisable(){
//         if (instanceBuffer != null){
//             instanceBuffer.Release();
//             instanceBuffer = null;
//             bufferInitialized = false;}}

//     Mesh CreateQuad(){
//         Mesh mesh = new Mesh();
//         mesh.vertices = new Vector3[]{
//             new Vector3(-0.5f,-0.5f,0),
//             new Vector3(0.5f,-0.5f,0),
//             new Vector3(0.5f,0.5f,0),
//             new Vector3(-0.5f,0.5f,0)};
//         mesh.uv = new Vector2[]{
//             new Vector2(0,0),
//             new Vector2(1,0),
//             new Vector2(1,1),
//             new Vector2(0,1)};
//         mesh.triangles = new int[]{0,1,2,0,2,3};return mesh;}

//     void OnDrawGizmos(){
//         if (positions == null) return;
//         Gizmos.color = Color.red;
//         foreach (var pos in positions)
//             Gizmos.DrawSphere(pos,0.1f);}
// }



// public class TimeLineSpriteComputeInstancer : MonoBehaviour
// {
//     public SpriteRenderer sourceSprite;
//     public int startCount = 0;
//     public int maxInstances = 10000;
//     public int incrementPerFrame = 10;
//     public float scaleMultiplier = 1f;
//     public Vector3 minPosition = new Vector3(-100f, 0, -100f);
//     public Vector3 maxPosition = new Vector3(100f, 0, 100f);
//     public List<Vector3> positions = new List<Vector3>();
//     Mesh quadMesh;
//     public Material instancingMaterial;
//     ComputeBuffer instanceBuffer;

//     struct InstanceData{
//         public Vector3 position;
//         public int active; }
//     bool bufferInitialized = false;
//     public ComputeShader filterShader;
//     void FilterInstances(Vector3 playerPos, float radius){
//         int kernel = filterShader.FindKernel("CSMain");
//         filterShader.SetBuffer(kernel, "instanceBuffer", instanceBuffer);
//         filterShader.SetVector("playerPos", playerPos);
//         filterShader.SetFloat("radius", radius);

//         int threadGroups = Mathf.CeilToInt(positions.Count / 256f);
//         filterShader.Dispatch(kernel, threadGroups, 1, 1);

//         AsyncGPUReadback.Request(instanceBuffer, req =>{
//             if(req.hasError) return;
//             InstanceData[] data = req.GetData<InstanceData>().ToArray();

//             // active==0 olanları yok et
//             for(int i = 0; i < data.Length; i++){
//                 if(data[i].active == 0)
//                     positions[i] = Vector3.negativeInfinity;            }
//             UpdateBuffer();});}

//     void Start(){
//         if (sourceSprite == null || sourceSprite.sprite == null) return;
//         if (quadMesh == null)
//             quadMesh = CreateQuad();
//         if (instancingMaterial == null){
//             Shader shader = Shader.Find("CustomUnlit/SingleSpriteCompute");
//             instancingMaterial = new Material(shader);
//             instancingMaterial.mainTexture = sourceSprite.sprite.texture;
//             instancingMaterial.enableInstancing = true;}
//         sourceSprite.enabled = false;
//         for (int i = 0; i < startCount; i++)
//             AddRandomPosition();
//         instanceBuffer = new ComputeBuffer(positions.Count, sizeof(float) * 4);
//         bufferInitialized = true;
//         UpdateBuffer();}

//     void Update(){
//         if (!bufferInitialized) return;
//         for (int i = 0; i < incrementPerFrame && positions.Count < maxInstances; i++)
//             AddRandomPosition();
//         UpdateBuffer();
//         instancingMaterial.SetBuffer("_InstanceDataBuffer", instanceBuffer);
//         Graphics.DrawMeshInstancedProcedural(
//             quadMesh, 0, instancingMaterial,
//             new Bounds(Vector3.zero, Vector3.one * 100f),
//             positions.Count);}

//     void AddRandomPosition(){
//         Vector3 pos = new Vector3(
//             Random.Range(minPosition.x, maxPosition.x),
//             Random.Range(minPosition.y, maxPosition.y),
//             Random.Range(minPosition.z, maxPosition.z));
//         positions.Add(pos);}

//     void UpdateBuffer(){
//         if (instanceBuffer != null)
//             instanceBuffer.Release();
//         instanceBuffer = new ComputeBuffer(positions.Count, sizeof(float) * 4);
//         InstanceData[] dataArray = new InstanceData[positions.Count];
//         for (int i = 0; i < positions.Count; i++)
//             dataArray[i] = new InstanceData { position = positions[i], active=0 };
//         instanceBuffer.SetData(dataArray);}
//     void OnDrawGizmosSelected()
//     {
//         if (positions == null) return;

//         Vector3 areaCenter = (minPosition + maxPosition) / 2f;
//         Vector3 areaSize = maxPosition - minPosition;
//         Gizmos.color = Color.blue;
//         Gizmos.DrawWireCube(areaCenter, areaSize);

// #if UNITY_EDITOR
//     GUIStyle style = new GUIStyle();
//     style.normal.textColor = Color.white;
//     style.fontSize = 12;
//     UnityEditor.Handles.Label(areaCenter + Vector3.up * (areaSize.y / 2f + 1f), 
//                               $"Instances: {positions.Count}\nArea: {areaSize}", style);
// #endif
//     }


//     void OnDisable(){
//         if (instanceBuffer != null){
//             instanceBuffer.Release();
//             instanceBuffer = null;
//             bufferInitialized = false;}}

//     Mesh CreateQuad(){
//         Mesh mesh = new Mesh();
//         mesh.vertices = new Vector3[]{
//             new Vector3(-0.5f,-0.5f,0),
//             new Vector3(0.5f,-0.5f,0),
//             new Vector3(0.5f,0.5f,0),
//             new Vector3(-0.5f,0.5f,0)};
//         mesh.uv = new Vector2[]{
//             new Vector2(0,0),
//             new Vector2(1,0),
//             new Vector2(1,1),
//             new Vector2(0,1)};
//         mesh.triangles = new int[]{0,1,2,0,2,3};return mesh;}

//     void OnDrawGizmos(){
//         if (positions == null) return;
//         Gizmos.color = Color.red;
//         foreach (var pos in positions)
//             Gizmos.DrawSphere(pos, 0.1f);}}



// public class PlayerDetection : MonoBehaviour
// {
//     public GameObject Player;
//     public SpriteRenderer sourceSprite;
//     public int startCount = 0;
//     public int maxInstances = 10000;
//     public int incrementPerFrame = 10;
//     public float scaleMultiplier = 1f;
//     public Vector3 minPosition = new Vector3(-100f, 0, -100f);
//     public Vector3 maxPosition = new Vector3(100f, 0, 100f);
//     public ComputeShader filterShader;
//     public List<Vector3> positions;
//     Mesh quadMesh;
//     Material instancingMaterial;
//     ComputeBuffer originalBuffer;   // structured buffer for instance data
//     ComputeBuffer filteredBuffer;   // append buffer for filtered results
//     ComputeBuffer counterBuffer;    // small buffer to hold the append count (1 uint)

//     struct InstanceData{
//         public Vector3 position;
//         public int active;}

//     bool bufferInitialized = false;
//     int stride;

//     void Start(){
//         if (sourceSprite == null || sourceSprite.sprite == null) return;
//         if (Player == null) Debug.LogWarning("Player is null in PlayerDetection.");
//         quadMesh = CreateQuad();
//         Shader shader = Shader.Find("CustomUnlit/SingleSpriteCompute_GPUActive");
//         instancingMaterial = new Material(shader);
//         instancingMaterial.mainTexture = sourceSprite.sprite.texture;
//         instancingMaterial.enableInstancing = true;
//         sourceSprite.enabled = false;
//         positions = new List<Vector3>(new Vector3[maxInstances]);
//         for (int i = 0; i < startCount; i++)
//             AddRandomPosition(i);
//         stride = sizeof(float) * 3 + sizeof(int);
//         originalBuffer = new ComputeBuffer(maxInstances, stride, ComputeBufferType.Default);
//         filteredBuffer = new ComputeBuffer(maxInstances, stride, ComputeBufferType.Append);
//         filteredBuffer.SetCounterValue(0);
//         counterBuffer = new ComputeBuffer(1, sizeof(uint), ComputeBufferType.Raw);
//         bufferInitialized = true;
//         UpdateBuffer();}

//     void Update(){
//         if (!bufferInitialized) return;
//         filteredBuffer.SetCounterValue(0);
//         Vector3 playerPos = Player != null ? Player.transform.position : Vector3.zero;
//         FilterInstances(playerPos, 1f);
//         int countAdded = 0;
//         for (int i = 0; i < positions.Count && countAdded < incrementPerFrame; i++){
//             if (positions[i] == Vector3.zero || positions[i] == Vector3.negativeInfinity){
//                 AddRandomPosition(i);
//                 countAdded++;}}
//         UpdateBuffer();
//         instancingMaterial.SetBuffer("_InstanceDataBuffer", originalBuffer);
//         Graphics.DrawMeshInstancedProcedural(
//             quadMesh, 0, instancingMaterial,
//             new Bounds(Vector3.zero, Vector3.one * 500f),
//             positions.Count);}

//     void FilterInstances(Vector3 playerPos, float radius){
//         int kernel = filterShader.FindKernel("CSMain");
//         filterShader.SetBuffer(kernel, "originalBuffer", originalBuffer);
//         filterShader.SetBuffer(kernel, "filteredBuffer", filteredBuffer);
//         filterShader.SetVector("playerPos", new Vector4(playerPos.x, playerPos.y, playerPos.z, 0f));
//         filterShader.SetFloat("radius", radius);
//         int threadGroups = Mathf.CeilToInt(positions.Count / 256f);
//         filterShader.Dispatch(kernel, threadGroups, 1, 1);
//         ComputeBuffer.CopyCount(filteredBuffer, counterBuffer, 0);
//         uint[] countData = new uint[1];
//         counterBuffer.GetData(countData);
//         int filteredCount = (int)countData[0];
//         Debug.Log($"Filtered count (GPU reported): {filteredCount}");
//         if (filteredCount > 0){
//             int byteSize = filteredCount * stride;
//             AsyncGPUReadback.Request(filteredBuffer, byteSize, 0, req =>{
//                 if (req.hasError){
//                     Debug.LogError("GPU Readback error!");return;}
//                 var data = req.GetData<InstanceData>();
//                 Debug.Log($"Async readback returned {data.Length} items");});}}

//     void AddRandomPosition(int index){
//         positions[index] = new Vector3(
//             Random.Range(minPosition.x, maxPosition.x),
//             Random.Range(minPosition.y, maxPosition.y),
//             Random.Range(minPosition.z, maxPosition.z));}

//     void UpdateBuffer(){
//         if (originalBuffer == null) return;
//         InstanceData[] dataArray = new InstanceData[positions.Count];
//         for (int i = 0; i < positions.Count; i++)
//             dataArray[i] = new InstanceData{
//                 position = positions[i],
//                 active = (positions[i] == Vector3.negativeInfinity) ? 0 : 1};
//         originalBuffer.SetData(dataArray);}

//     void OnDisable(){
//         originalBuffer?.Release();
//         filteredBuffer?.Release();
//         counterBuffer?.Release();
//         originalBuffer = filteredBuffer = null;
//         bufferInitialized = false;}

//     Mesh CreateQuad(){
//         Mesh mesh = new Mesh();
//         mesh.vertices = new Vector3[]{
//             new Vector3(-0.5f,-0.5f,0),
//             new Vector3(0.5f,-0.5f,0),
//             new Vector3(0.5f,0.5f,0),
//             new Vector3(-0.5f,0.5f,0)};
//         mesh.uv = new Vector2[]{
//             new Vector2(0,0),
//             new Vector2(1,0),
//             new Vector2(1,1),
//             new Vector2(0,1)};
//         mesh.triangles = new int[]{0,1,2,0,2,3};
//         mesh.RecalculateNormals();
//         return mesh;}}
